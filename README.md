# minimalAgent

A minimalistic implementation of an LLM agent that can write actions in code to solve tasks.
The focus of this code is on simplicity. The goal is purely educational.

This focus implies tradeoffs. For example, there are fewer validation steps or edge cases covered than one would like to see in a full-blown library. But it pays off. The core `agent.py` module is only ~100 lines long (excluding extensive comments). 

The code demonstrates how easily one can build a simple yet effective LLM agent without the complexity of larger frameworks. It implements the core components necessary for agent functionality - task processing, tool usage, and iterative problem-solving - with minimal abstractions and dependencies.

The agent itself is built from scratch using just a few libraries and extensively commented.

It is inspired by Hugging Face's Smolagents library. Smolagents' python exectutor is also used for the execution of the code generated by the coding agent - but nothing more (see code). It would be too complex and distracting to add this python executor to this repo.

## Usage

Clone and install:

1. Install [`uv`](https://docs.astral.sh/uv/getting-started/installation/) for Python packaging and environment creation.

2. Clone the repo:
```bash
git clone https://github.com/yourusername/minimal-agent.git
cd minimal-agent
```

3. The repo uses [LiteLLM](https://docs.litellm.ai/) to support a unified interface across all model providers Add the model name and the API keys/secrets of the corresponding provider. Create a `.env` file in the `minimal-agent` folder. Add the `MODEL` environment variable with name of the model as specified on LiteLLM, and he credentials for the correspoding provider. Below are two examples:

```bash
# AWS Bedrock: https://docs.litellm.ai/docs/providers/bedrock
AWS_ACCESS_KEY_ID=<YOUR-AWS-ACCESS-KEY-ID>
AWS_SECRET_ACCESS_KEY=<YOUR-AWS-SECRET-ACCESS-KEY>
AWS_REGION_NAME=<YOUR-AWS-REGION-NAME>

MODEL="bedrock/anthropic.claude-3-7-sonnet-20250219-v1:0"
```

```bash
# Google Gemini: https://docs.litellm.ai/docs/providers/gemini
GEMINI_API_KEY=<YOUR-API-KEY>

MODEL="gemini/gemini-2.0-flash"
```

For other model providers refer to the [LiteLLM documentation](https://docs.litellm.ai/docs/providers). Note that coding agents require powerfull LLMs, such as Claude 3.7 or Gemini 2.0 Flash. While you can use this code with less powerful models, the results might not be great.

4. Run the example:
```bash
uv run run_agent.py
```

The default example runs a query about "the hottest day in 2024 and the Dow Jones value on that day." and provides the agent with the ability to search the internet and visit websites to find the answer.

Go ahead, try it out and modify the task in `run_agent.py`.
```python
res = agent.run("<Your task here in natural language>")
```

## Philosophy

### Why Not Use Existing Frameworks?

Developers often use complex agent frameworks to address even simple use cases. These frameworks can be convenient for quick implementation but introduce many layers of abstraction that complicate debugging and optimization. This complexity is one reason why agents are frequently perceived as mysterious and developers struggle to productionize them.

### Inspiration from Smolagents

The code draws inspiration from Hugging Face's Smolagents library, which already makes efforts to reduce complexity while providing a framework purpose-built for code agents (i.e. agents that perform actions by writing and executing code). However, even Smolagents be challenging to fully understand or modify its behavior.

### Core Agent Principles

At its essence, an agent only needs to:
1. Receive a task and access appropriate tools
2. Determine how to solve the task using available tools
3. Execute actions based on that reasoning
4. Observe results and iterate until completion

### Practical Considerations

Many agent frameworks add complexity by:
- Abstracting across multiple model providers
- Handling numerous edge cases
- Adding performance-enhancing features (like planning stages)

This can be very useful. The code in this repo might fail for several tasks precisely because it, for example, doesn't address these edge cases for a given set of taks.

However, for specific use cases with very narrow tasks, it's often more effective to start with simpler code like this example and tailor it the requirements rather than adapting a more complex framework.
